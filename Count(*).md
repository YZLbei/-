# Count(*)

## count(*)的实现方式

MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数， 效率很高； 

而InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。 



但是加了过滤条件，MyISAM也不会很快
## 为什么InnoDB要这样

因为MVCC（多版本并发控制），同一时刻的多个查询返回也不能确定返回多少行



优化：因为主键索引和普通索引，遍历的结果是相同的，而普通索引的树更小，所以MySQL优化器会找到最小的那棵树来遍历

**在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一**



如果频繁的需要计数，如何解决？

**只能自己计数**
## 用缓存系统保存计数

但是会出现不精确的情况，因为存在查询时Redis中还没来得及更新计数，或者Redis中已经更新但是查询不到更新数据的情况

## 用数据库保存计数

1. 可以解决缓存重启的问题
2. 利用事务可以解决数据不一致的问题，对于当前事务只能看见已经提交的数据

## 不同的count操作

count操作是server层要什么，引擎层就给什么

对count( 主键id)来说，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server 层。
对count(1)来说，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个 数字“1”进去，判断是不可能为空的，按行累加

count(1)执行得要比count(主键id)快。



count（字段）也是取出来判断是否为空，再累加

但是count(*)做了优化，不取值。count ( * )肯定不是null，按行累加。



按照效率排序的话，count(字段)<count(主键id)<count(1)≈count(*)
