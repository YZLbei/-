# 事务隔离

## 隔离性与隔离级别

ACID（原子性、一致性、隔离性、持久性）



隔离越严效率越低



- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。 
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。 
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一 致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突 的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

## 事务隔离的实现

1. 依靠**MVCC**，数据库的多版本并发控制，就是同一个记录在系统中可以有多个版本；

2. InnoDB的行数据有多个版本，每个数据版本有自己的rowtrx_id（事务id），每个事务或者语句有自己的一 致性视图。

3. 不同时刻启动的事务会有不同的read-view（一致性视图）；

4. 事务看到的就是自己的一致性视图，就保证了隔离级别级别的实现。

5. 

   1. 事务id是什么
   2. 一致性视图是怎么生成的
   3. 怎么根据一致性视图保证隔离

   ## MVCC

同一条记录在系统中可以存在多 个版本，就是数据库的多版本并发控制（MVCC）

InnoDB的行数据有多个版本，每个数据版本有自己的rowtrx_id，每个事务或者语句有自己的一 致性视图。

MVCC的实现就是一致性视图，可以支持读题交和可重复读；

## 视图

视图有两个概念

- 一个是view，查询语句定义的虚拟表，调用的时候执行查询语句并生成结果；
- 另一个是InnoDB在实现MVCC时用到的一致性视图，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。

## 快照在Mysql中是怎么工作的

**InnoDB利用了 “所有数据都有多个版本 ”的这个特性，实现了“秒级创建快照”的能力**。

在可重复读隔离级别下，事务在启动的时候就“拍了个快照”；注意，这个快照是基于整库的。



1. InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向 InnoDB的事务系统申请的，是按申请顺序**严格递增**的；
2. InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，所有启动了还没提交的事务ID。这个数组就是一致性视图。

数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位。

这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。

一致性视图就是当前未提交事务的集合；

![image-20220816104815578](https://buketyzl.oss-cn-qingdao.aliyuncs.com/image-20220816104815578.png)

1. 普通查询语句是一致性读，一致性读会根据rowtrx_id和一致性视图确定数据版本的可见性。 

2. 对于可重复读，查询只承认在事务启动前就已经提交完成的数据；

3. 对于读提交，查询只承认在**语句启动前**就已经**提交**完成的数据； 

4. 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询 都共用这个一致性视图； 

5. 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。

   

   

可重复读级别：

一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况

1. 版本未提交，不可见； 
2. 版本已提交，但是是在视图创建后提交的，不可见； 
3. 版本已提交，而且是在视图创建前提交的，可见。



如果是读提交

就是把视图创建替换成语句执行前

## 更新逻辑

### 当前读

更新数据都是先读后写的，而这个读，只能读当前的值，称为**当前读**（current read）。

如果一个事务A更新了一行数据，但是还没提交，另一个事务B要更新这条数据，会发生什么情况？

A事务没提交，说明这个版本上的写锁还没释放；而事务B是当前读，必须要读到最新版本，而且必须加锁，因此事务B会被锁住，必须等到事务A释放这个锁，才能继续当前读(把一致性读、当前读和行锁就串起来了)



## 事务的可重复读的能力是怎么实现的？

可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如 果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。 

而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是： 

在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询 都共用这个一致性视图； 

在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。 

## 总结

InnoDB的行数据有多个版本，每个数据版本有自己的rowtrx_id，每个事务或者语句有自己的一 致性视图。

普通查询语句是一致性读，一致性读会根据rowtrx_id和一致性视图确定数据版本的可见性。 

对于可重复读，查询只承认在事务启动前就已经提交完成的数据；

对于读提交，查询只承认在**语句启动前**就已经**提交**完成的数据； 

而**当前读**，总是读取已经提交完成的最新版本。 

你也可以想一下，为什么表结构不支持“可重复读”？这是因为表结构没有对应的行数据，也没有 rowtrx_id，因此只能遵循当前读的逻辑。 
